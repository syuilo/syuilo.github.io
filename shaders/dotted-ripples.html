<!doctype html>

<html>
	<head>
		<meta charset="utf-8">

		<style>
html, body {
	width: 100%;
	height: 100%;
	margin: 0;
	background: #000;
}

input[type="range"] {
	display: block;
	width: 100%;
	box-sizing: border-box;
	margin: 0;
}
		</style>
	</head>

	<body>
		<canvas id="canvas" style="display: block; width: 100%; height: 100%;"></canvas>

		<script src="./common.js"></script>

		<script>
const canvas = document.getElementById('canvas');

const VERTEX_SHADER = `#version 300 es
in vec2 position;
out vec2 in_uv;

void main() {
	in_uv = (position + 1.0) / 2.0;
	gl_Position = vec4(position, 0.0, 1.0);
}
`;

const FRAGMENT_SHADER = `#version 300 es
precision mediump float;

${GLSL_COMMON}

in vec2 in_uv;
uniform vec2 in_resolution;
uniform int u_time;
uniform float u_scale;
uniform float u_seed;
uniform float u_radius;
uniform vec2 u_ripplePositions[16];
uniform float u_rippleRadiuses[16];
uniform vec3 u_rippleColors[16];
out vec4 out_color;

vec3 getRipple(vec2 uv) {
	vec3 v = vec3(0.0);
	float thickness = 0.05;

	for (int i = 0; i < 16; i++) {
		float ru = u_rippleRadiuses[i];
		vec2 rp = u_ripplePositions[i];
		vec3 rc = u_rippleColors[i];

		if (ru <= 0.0) continue;

		float d = distance(uv, rp);

		// フチ
		if (d < ru + thickness && d > ru - thickness) {
			float gradate =  abs(d - ru + thickness) / thickness;
			v += rc * ((1.0 - ru) * gradate);
		}

		// 内側
		if (d < ru + thickness) {
			v += rc * (0.3 * (1.0 - ru));
		}
	}

	return min(max(v, 0.0), 1.0);
}

void main() {
	float x_ratio = min(in_resolution.x / in_resolution.y, 1.0);
	float y_ratio = min(in_resolution.y / in_resolution.x, 1.0);

	vec2 centeredUv = (in_uv - vec2(0.5, 0.5)) * vec2(x_ratio, y_ratio);
	vec2 uv = centeredUv;

	float time = float(u_time) * 0.00025;

	float size = 1.0 / u_scale;
	float size_half = size / 2.0;
	float modX = mod(uv.x, size);
	float modY = mod(uv.y, size);

	vec2 pixelated_uv = vec2(
		(size * (floor((uv.x - 0.5 - size) / size) + 0.5)),
		(size * (floor((uv.y - 0.5 - size) / size) + 0.5))
	) + vec2(0.5 + size, 0.5 + size);

	vec3 v = getRipple(pixelated_uv);

	float threshold = ((u_radius / 2.0) / u_scale);
	if (length(vec2(modX - size_half, modY - size_half)) < threshold) {
		out_color = vec4(v.r, v.g, v.b, 1.0);
		return;
	}

	// debug
	//out_color = vec4(v.r, v.g, v.b, 0.5);
	out_color = vec4(0.0, 0.0, 0.0, 0.0);
}
`;

const { gl, program, render } = makeGl(canvas, VERTEX_SHADER, FRAGMENT_SHADER);

const u_seed = gl.getUniformLocation(program, 'u_seed');
const u_scale = gl.getUniformLocation(program, 'u_scale');
const u_radius = gl.getUniformLocation(program, 'u_radius');
gl.uniform1f(u_seed, 1000);
gl.uniform1f(u_scale, 48);
gl.uniform1f(u_radius, 0.15);

let ripples = [];
const LIFE_TIME = 1000 * 4;

function hsvToRgb(h, s, v) {
	let r, g, b;

	let i = Math.floor(h * 6);
	let f = h * 6 - i;
	let p = v * (1 - s);
	let q = v * (1 - f * s);
	let t = v * (1 - (1 - f) * s);

	switch (i % 6) {
		case 0: r = v, g = t, b = p; break;
		case 1: r = q, g = v, b = p; break;
		case 2: r = p, g = v, b = t; break;
		case 3: r = p, g = q, b = v; break;
		case 4: r = t, g = p, b = v; break;
		case 5: r = v, g = p, b = q; break;
	}

	return [r, g, b];
}

function drop(timeStamp, x, y) {
	if (ripples.length >= 16) return;
	const _x = x ?? (Math.random() * 1) - 0.5;
	const _y = y ?? (Math.random() * 1) - 0.5;
	const hue = Math.random();
	const color = hsvToRgb(hue, 1, 1);
	ripples.push({ position: [_x, _y], startTime: timeStamp, color });
}

const uniformLocations_rp = [];
const uniformLocations_rr = [];
const uniformLocations_rc = [];
for (let i = 0; i < 16; i++) {
	uniformLocations_rp.push(gl.getUniformLocation(program, `u_ripplePositions[${i.toString()}]`));
	uniformLocations_rr.push(gl.getUniformLocation(program, `u_rippleRadiuses[${i.toString()}]`));
	uniformLocations_rc.push(gl.getUniformLocation(program, `u_rippleColors[${i.toString()}]`));
}

let t = 0;

render((timeStamp) => {
	t = timeStamp;

	if (Math.random() < 0.01) {
		drop(timeStamp);
	}

	for (let i = 0; i < 16; i++) {
		const p = uniformLocations_rp[i];
		const r = uniformLocations_rr[i];
		const c = uniformLocations_rc[i];
		const ripple = ripples[i];
		if (ripple == null) {
			gl.uniform2f(p, 0, 0);
			gl.uniform1f(r, 0.0);
			gl.uniform3fv(c, [0, 0, 0]);
			continue;
		}

		const delta = timeStamp - ripple.startTime;

		gl.uniform2f(p, ripple.position[0], ripple.position[1]);
		gl.uniform1f(r, delta / LIFE_TIME);
		gl.uniform3fv(c, ripple.color);
	}

	ripples = ripples.filter(r => (timeStamp - r.startTime) < LIFE_TIME);
	if (ripples.length === 0) {
		drop(timeStamp);
	}
});

canvas.addEventListener('click', (ev) => {
	const rect = canvas.getBoundingClientRect();
	const w = rect.width;
	const h = rect.height;
	const aspectX = w / Math.max(w, h);
	const aspectY = h / Math.max(w, h);
	const x = ((ev.clientX - rect.left) / w - 0.5) * aspectX;
	const y = -((ev.clientY - rect.top) / h - 0.5) * aspectY;
	console.log(x, y);
	drop(t, x, y);
});
		</script>
	</body>
</html>
