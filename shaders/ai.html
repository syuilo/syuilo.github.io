<!doctype html>

<html>
	<head>
		<meta charset="utf-8">

		<style>
html, body {
	width: 100%;
	height: 100%;
	margin: 0;
	background: #ddd;
}

input[type="range"] {
	display: block;
	width: 100%;
	box-sizing: border-box;
	margin: 0;
}
		</style>
	</head>

	<body>
		<canvas id="canvas" style="display: block; width: 100%; height: 100%;"></canvas>
		<!--
		<div>
			<div>
				<label for="u_radius">Radius</label>
				<input type="range" id="u_radius" min="0" max="2" step="0.01" />
			</div>
		</div>
		-->

		<script src="./common.js"></script>

		<script>
const canvas = document.getElementById('canvas');

const VERTEX_SHADER = `#version 300 es
in vec2 position;
out vec2 in_uv;

void main() {
	in_uv = (position + 1.0) / 2.0;
	gl_Position = vec4(position, 0.0, 1.0);
}
`;

const FRAGMENT_SHADER = `#version 300 es
precision mediump float;

${GLSL_COMMON}

in vec2 in_uv;
uniform vec2 in_resolution;
uniform int u_time;
uniform float u_scale;
uniform float u_seed;
uniform float u_radius;
out vec4 out_color;

void main() {
	float x_ratio = min(in_resolution.x / in_resolution.y, 1.0);
	float y_ratio = min(in_resolution.y / in_resolution.x, 1.0);

	float u_angle = 0.0;
	float angle = -(u_angle * PI);
	vec2 centeredUv = (in_uv - vec2(0.5, 0.5)) * vec2(x_ratio, y_ratio);
	vec2 rotatedUV = vec2(
		centeredUv.x * cos(angle) - centeredUv.y * sin(angle),
		centeredUv.x * sin(angle) + centeredUv.y * cos(angle)
	);
	vec2 uv = rotatedUV;

	uv = uv;

	float time = float(u_time) * 0.00025;

	float noiseScale = 32.0;
	vec2 noiseUV = uv;
	float d = distance(uv, vec2(0.0, 0.0));
	noiseUV.x = noiseUV.x * d * d * d;
	noiseUV.y = noiseUV.y * d * d * d;

	noiseUV *= 64.0;

	float noiseRScale = noiseScale;
	float noiseRX = (noiseUV.x + u_seed + 1.0) * (u_scale / noiseRScale);
	float noiseRY = (noiseUV.y + u_seed + 1.0) * (u_scale / noiseRScale);
  float noiseR = snoise(vec3(noiseRX, noiseRY, time));

	float noiseGScale = noiseScale;
	float noiseGX = (noiseUV.x + u_seed + 2.0) * (u_scale / noiseGScale);
	float noiseGY = (noiseUV.y + u_seed + 2.0) * (u_scale / noiseGScale);
	float noiseG = snoise(vec3(noiseGX, noiseGY, time));

	float noiseBScale = noiseScale;
	float noiseBX = (noiseUV.x + u_seed + 3.0) * (u_scale / noiseBScale);
	float noiseBY = (noiseUV.y + u_seed + 3.0) * (u_scale / noiseBScale);
	float noiseB = snoise(vec3(noiseBX, noiseBY, time));

	if (length(uv) < u_radius) {
		//vec3 c = vec3(0.5);
		vec3 c = vec3(0.0);
		c = mix(c, vec3(1.0, 0.0, 0.0), noiseR);
		c = mix(c, vec3(0.0, 1.0, 0.0), noiseG);
		c = mix(c, vec3(0.0, 0.0, 1.0), noiseB);
		c = normalize(c);
		c = min(c + vec3(1.0), vec3(1.0));

		c = min(max(c, vec3(0.0)), vec3(1.0));
		out_color = vec4(c.r, c.g, c.b, 1.0);
		return;
	}

	out_color = vec4(0.0, 0.0, 0.0, 0.0);
}
`;

const { gl, program, render } = makeGl(canvas, VERTEX_SHADER, FRAGMENT_SHADER);

const u_seed = gl.getUniformLocation(program, 'u_seed');
const u_scale = gl.getUniformLocation(program, 'u_scale');
const u_radius = gl.getUniformLocation(program, 'u_radius');
gl.uniform1f(u_seed, 1000);
gl.uniform1f(u_scale, 48);
gl.uniform1f(u_radius, 0.25);

render();

/*
document.getElementById('u_radius').addEventListener('input', (e) => {
	const v = parseFloat(e.target.value);
	gl.uniform1f(u_radius, v);
});
*/
		</script>
	</body>
</html>
