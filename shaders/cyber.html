<!doctype html>

<html>
	<head>
		<meta charset="utf-8">

		<style>
html, body {
	width: 100%;
	height: 100%;
	margin: 0;
	background: #000;
}

input[type="range"] {
	display: block;
	width: 100%;
	box-sizing: border-box;
	margin: 0;
}
		</style>
	</head>

	<body>
		<canvas id="canvas" style="display: block; width: 100%; height: 100%;"></canvas>

		<script src="./common.js"></script>

		<script>
const canvas = document.getElementById('canvas');

const VERTEX_SHADER = `#version 300 es
in vec2 position;
out vec2 in_uv;

void main() {
	in_uv = (position + 1.0) / 2.0;
	gl_Position = vec4(position, 0.0, 1.0);
}
`;

const FRAGMENT_SHADER = `#version 300 es
precision mediump float;
precision mediump sampler2DArray;

${GLSL_COMMON}

in vec2 in_uv;
uniform vec2 in_resolution;
uniform int u_time;
uniform sampler2DArray u_textures;
uniform int u_texturesCount;
uniform float u_divisions;
uniform float u_seed;
uniform vec2 u_ripplePositions[4];
uniform float u_rippleRadiuses[4];
uniform vec2 u_pointer;
out vec4 out_color;

float getRipple(vec2 uv) {
	float v = 0.0;
	float thickness = 0.075;

	for (int i = 0; i < 4; i++) {
		float ru = u_rippleRadiuses[i];
		vec2 rp = u_ripplePositions[i];

		if (ru <= 0.0) continue;

		float d = distance(uv, rp);

		// フチ
		if (d < ru + thickness && d > ru - thickness) {
			float gradate =  abs(d - ru + thickness) / thickness;
			v += ((1.0 - ru) * gradate);
		}

		//// 内側
		//if (d < ru + thickness) {
		//	v += (0.3 * (1.0 - ru));
		//}
	}

	return v;
}

float getPointerForce(vec2 uv) {
	if (u_pointer.x == -1.0 && u_pointer.y == -1.0) return 0.0;

	float v = 0.0;
	float thickness = 0.05;
	float radius = 0.1;

	float d = distance(uv, u_pointer);
	if (d < radius + thickness && d > radius - thickness) {
		float gradate =  abs(d - radius + thickness) / thickness;
		v += ((1.0 - radius) * gradate);
	}

	return v;
}

void main() {
	float time = float(u_time);

	float x_ratio = max(in_resolution.x / in_resolution.y, 1.0);
	float y_ratio = max(in_resolution.y / in_resolution.x, 1.0);

	vec2 centeredUv = (in_uv - vec2(0.5, 0.5)) * vec2(x_ratio, y_ratio);
	vec2 uv = centeredUv;

	vec2 scroll = vec2(0.0, -time * 0.0002);

	vec2 cellSize = vec2(1.0 / u_divisions, 1.0 / u_divisions);

	float border = 0.25;

	vec2 modUv = vec2(mod(uv - 0.5, cellSize));

	vec2 cellSize2 = cellSize * 2.0;
	vec2 modUv2 = vec2(mod(uv - 0.5, cellSize2));
	vec2 cellSize4 = cellSize * 4.0;
	vec2 modUv4 = vec2(mod(uv - 0.5, cellSize4));

	vec2 cellUv2 = cellSize2 * floor((uv - 0.5) / cellSize2);
	cellUv2 += cellSize2 / 2.0;
	cellUv2 += 0.5;
	vec2 cellUv4 = cellSize4 * floor((uv - 0.5) / cellSize4);
	cellUv4 += cellSize4 / 2.0;
	cellUv4 += 0.5;

	float cellMultiplier2Noise = snoise0to1(vec3(cellUv2.x * 3.0, cellUv2.y * 3.0, time * 0.00005));
	float cellMultiplier4Noise = snoise0to1(vec3(cellUv4.x * 3.0, cellUv4.y * 3.0, time * 0.00005));
	if (cellMultiplier4Noise > 0.9) {
		modUv = modUv4;
		cellSize = cellSize4;
		border /= 4.0;
	} else if (cellMultiplier2Noise > 0.75) {
		modUv = modUv2;
		cellSize = cellSize2;
		border /= 2.0;
	}

	vec2 cellUv = cellSize * floor((uv - 0.5) / cellSize);
	cellUv += cellSize / 2.0;
	cellUv += 0.5;

	float ripple = getRipple(cellUv);
	float pointerForce = getPointerForce(cellUv);

	float texSelector = snoise0to1(vec3((cellUv * 3.0) + scroll, time * 0.00002));
	if (ripple > 0.5) {
		texSelector += 0.25;
		//texSelector *= 1.5;
		texSelector = min(texSelector, 1.0);
	}
	if (pointerForce > 0.0) {
		texSelector += pointerForce * 0.25;
		texSelector = min(texSelector, 1.0);
	}

	float scaleNoise = snoise0to1(vec3(cellUv * 0.7, time * 0.000025));
	//float scale = scaleNoise > 0.25 ? 0.75 : 0.4;
	float scale = scaleNoise > 0.25 ? 1.0 : 0.4;
	scale = min(scale, 1.0 - border);
	if (ripple > 0.5) {
		scale = 1.0;
	}

	float visibilityNoiseA = snoise0to1(vec3(cellUv + scroll, time * 0.0000125));
	float visibilityNoiseB = snoise0to1(vec3(cellUv * 8.0, time * 0.0000125));
	float threshold = 0.65;
	if (ripple > 0.5) threshold -= 0.1;
	float visibility = mix(visibilityNoiseA, visibilityNoiseB, 0.5) > threshold ? 1.0 : 0.0;

	//if (ripple > 0.5) {
	//	visibility = 0.2;
	//}

	float colorNoise = snoise0to1(vec3((cellUv * 8.0) + scroll, time * 0.00005));

	//out_color = vec4(vec3(texSelector), 1.0);
	//return;

	// background dots and blocks
	if (visibility == 0.0) {
		float n = mix(visibilityNoiseA, visibilityNoiseB, 0.2);
		if (n > 0.75) {
			// iOSだとおかしい
			//out_color = vec4(1.0, 1.0, 1.0, 0.05);
			out_color = vec4(0.05, 0.05, 0.05, 1.0);
			return;
		} else if (n > 0.5) {
			if (distance(modUv / cellSize, vec2(0.5, 0.5)) < 0.05) {
				// iOSだとおかしい
				//out_color = vec4(1.0, 1.0, 1.0, 0.25);
				out_color = vec4(0.25, 0.25, 0.25, 1.0);
				return;
			}
		}
	}

	if (
		(modUv.x / cellSize.x) > (1.0 - scale) / 2.0 &&
		(modUv.x / cellSize.x) < 0.5 + (scale / 2.0) &&
		(modUv.y / cellSize.y) > (1.0 - scale) / 2.0 &&
		(modUv.y / cellSize.y) < 0.5 + (scale / 2.0)
	) {
		vec2 margin = (1.0 - (0.5 + (scale / 2.0))) * cellSize;
		vec2 transformedCoords = (modUv - margin) / (cellSize - (margin * 2.0));
		
		// 正しい向きにする
		transformedCoords.y = 1.0 - transformedCoords.y;

		out_color = texture(u_textures, vec3(transformedCoords, texSelector * float(u_texturesCount - 1)));

		if (colorNoise > 0.9) {
			out_color.g *= 0.4;
			out_color.b = 0.0;
		//} else if (colorNoise > 0.85) {
		//	out_color.b = 0.0;
		} else if (colorNoise > 0.7) {
			out_color.r /= 1.25;
			out_color.b = 0.0;
		} else if (colorNoise > 0.35) {
			// iOSだとおかしい
			//out_color.r = 1.0;
			//out_color.g = 1.0;
			//out_color.b = 1.0;
		} else {
			// iOSだとおかしい
			//out_color.r = 1.0;
			//out_color.g = 1.0;
			//out_color.b = 1.0;
			//out_color.a *= 0.25;

			out_color.r *= 0.5;
			out_color.g *= 0.5;
			out_color.b *= 0.5;
		}

		out_color.a *= visibility;

		if (visibility == 0.0) {
			// iOSだとおかしい
			//out_color = vec4(1.0, 1.0, 1.0, ripple * 0.0125);
			out_color = vec4(0.0, 0.0, 0.0, 1.0);
		}
	} else {
	 	// iOSだとおかしい
		//out_color = vec4(vec3(0.0), 0.0);
		out_color = vec4(0.0, 0.0, 0.0, 1.0);
	}
}
`;

const { gl, program, render } = makeGl(canvas, VERTEX_SHADER, FRAGMENT_SHADER, 30);

const u_seed = gl.getUniformLocation(program, 'u_seed');
const u_divisions = gl.getUniformLocation(program, 'u_divisions');
gl.uniform1f(u_seed, 1000);
gl.uniform1f(u_divisions, getUrlParam('divisions', 'int') ?? 40);

let ripples = [];
const LIFE_TIME = 1000 * 2;

function drop(timeStamp, x, y) {
	if (ripples.length >= 4) return;
	const _x = x ?? (Math.random() * 1) - 0.5;
	const _y = y ?? (Math.random() * 1) - 0.5;
	ripples.push({ position: [_x, _y], startTime: timeStamp, });
}

const uniformLocations_rp = [];
const uniformLocations_rr = [];
for (let i = 0; i < 4; i++) {
	uniformLocations_rp.push(gl.getUniformLocation(program, `u_ripplePositions[${i.toString()}]`));
	uniformLocations_rr.push(gl.getUniformLocation(program, `u_rippleRadiuses[${i.toString()}]`));
}

const textureUrls = [
	'./assets/symbols/dot.png',
	'./assets/symbols/dots.png',
	'./assets/symbols/dots3.png',

	'./assets/symbols/o1.png',
	'./assets/symbols/o2.png',
	'./assets/symbols/o3.png',
	'./assets/symbols/o4.png',
	'./assets/symbols/x1.png',
	'./assets/symbols/x2.png',
	'./assets/symbols/cross1.png',
	'./assets/symbols/cross2.png',
	'./assets/symbols/slash1.png',
	'./assets/symbols/slash2.png',
	'./assets/symbols/corner.png',
	'./assets/symbols/block.png',

	...(getUrlParam('numbers', 'bool') ? [
		'./assets/chars/0.png',
		'./assets/chars/1.png',
		'./assets/chars/2.png',
		'./assets/chars/3.png',
		'./assets/chars/4.png',
		'./assets/chars/5.png',
		'./assets/chars/6.png',
		'./assets/chars/7.png',
		'./assets/chars/8.png',
		'./assets/chars/9.png',
	] : []),

	'./assets/symbols/square-slash.png',
	'./assets/symbols/stripe.png',
	'./assets/symbols/fill.png',
];

const u_texturesCount = gl.getUniformLocation(program, 'u_texturesCount');
gl.uniform1i(u_texturesCount, textureUrls.length);

const u_pointer = gl.getUniformLocation(program, 'u_pointer');
gl.uniform2f(u_pointer, -1.0, -1.0);

async function main() {
	const tex = await createTextureArrayFromUrls(gl, 256, 256, textureUrls);

	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D_ARRAY, tex);
	const u_texture = gl.getUniformLocation(program, `u_textures`);
	gl.uniform1i(u_texture, 0);

	let t = 0;

	render((timeStamp) => {
		t = timeStamp;

		for (let i = 0; i < 4; i++) {
			const p = uniformLocations_rp[i];
			const r = uniformLocations_rr[i];
			const ripple = ripples[i];
			if (ripple == null) {
				gl.uniform2f(p, 0, 0);
				gl.uniform1f(r, 0.0);
				continue;
			}

			const delta = timeStamp - ripple.startTime;

			gl.uniform2f(p, ripple.position[0], ripple.position[1]);
			gl.uniform1f(r, delta / LIFE_TIME);
		}

		ripples = ripples.filter(r => (timeStamp - r.startTime) < LIFE_TIME);
	});

	let lastClick = 0;

	canvas.addEventListener('click', (ev) => {
		if (t - lastClick < 400) return;
		lastClick = t;
		const rect = canvas.getBoundingClientRect();
		const w = rect.width;
		const h = rect.height;
		const aspectX = w / Math.min(w, h);
		const aspectY = h / Math.min(w, h);
		const x = ((ev.clientX - rect.left) / w - 0.5) * aspectX;
		const y = -((ev.clientY - rect.top) / h - 0.5) * aspectY;
		console.log(x, y);
		drop(t, x, y);
	});

	window.addEventListener('pointermove', (ev) => {
		const rect = canvas.getBoundingClientRect();
		const w = rect.width;
		const h = rect.height;
		const aspectX = w / Math.min(w, h);
		const aspectY = h / Math.min(w, h);
		const x = ((ev.clientX - rect.left) / w - 0.5) * aspectX;
		const y = -((ev.clientY - rect.top) / h - 0.5) * aspectY;
		gl.uniform2f(u_pointer, x, y);
	});
}

main();
		</script>
	</body>
</html>
